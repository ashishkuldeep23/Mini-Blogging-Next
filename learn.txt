

LEARN IN THIS PROJECT ======================================================================================>

Taliwind CSS new things ------------------>
    1. !m-0 :- this way we can give improtant to css property (by using !).

    2. duration-500 :- by this way we can give transition duration directly.

    3. aspect-square :- This prop will maintain aspect ration of an image.

    4. NODE_ENV=production node server.js :- this is how we can set env during starting our server.


Recat trick form taking props with rest operator -------------->

1. (Very useful in somecases)

({title , id , ...restProps} : {title : string , id : string , ...restProps})

<p id={id} {...restProps}>{title}</p>

Explain :- look above code this is how we can get n number of props and we can use those props in our code. And best part is that we don't need any extra typeScript code to decide restProps.



SOME UPDATED ==============================================================================================>

Post update ----------------->
    4. User can post a Image ✅
    6. User can upload profile pictures.✅
    2. Post custumizaton (like :- bg-color, border, Font-Family, may be heading size ). ✅

    1. Privacy for post [Public and private] .
    
    3. Post type Retweet feature.

    5. Socket IO (For messaging and notifications)
        => Not insted of using socket io, i'm usning Pusher js for real time communication.

    6. User can save a post that is posted by other user (Jaha pr edit delete btn hai agr post user ne nhi create kiya hai to user ushe apni profile me save kr sake)





====================================================================================================>> BEST WAY ------>>

    If you want to share a web that is present n ur local (Both devices should connected with same wifi)
        IP_OF_LEPTOP:PORT <<============= Search this into mobile phone.




=========================================================>>

See this err and my approch to fix this ( TS err ) ------->>

ERR -->>
Type '(string | UserDataInterface)[]' is not assignable to type 'UserDataInterface[]'.
  Type 'string | UserDataInterface' is not assignable to type 'UserDataInterface'.
    Type 'string' is not assignable to type 'UserDataInterface'.ts(2322)

FIX -->>
      <MainPostUI singlePost={{
                    ...singlePostdata,
                    likesId: (singlePostdata.likesId.length > 0 && typeof singlePostdata.likesId[0] !== "string")
                        ? singlePostdata.likesId.filter(post => typeof post !== "string")
                        : []
                }} />



============================================>>

https://ui.aceternity.com/components UI i'm using for ui in this project



==================================================>> 
For testing Next app on locally -------->>

If u r connected with same wifi then follow ur leptop ip address with port value.









=========================================>> Some Codes 


import { NextApiRequest, NextApiResponse } from 'next';
import connectDB from '../../../lib/mongodb';
import Conversation from '../../../models/Conversation';
import User from '../../../models/User';
import { verifyToken, getTokenFromRequest } from '../../../lib/auth';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    await connectDB();
    
    const { userId: targetUserId } = req.body;
    const token = getTokenFromRequest(req.headers.authorization);
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = verifyToken(token);
    const currentUserId = decoded.userId;

    // Prevent starting conversation with self
    if (currentUserId === targetUserId) {
      return res.status(400).json({ error: 'Cannot start conversation with yourself' });
    }

    // Verify target user exists
    const targetUser = await User.findById(targetUserId);
    if (!targetUser) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if direct conversation already exists
    let conversation = await Conversation.findOne({
      type: 'direct',
      participants: { 
        $all: [currentUserId, targetUserId], 
        $size: 2 
      },
      isActive: true,
    }).populate('participants', 'name username avatar isOnline lastSeen');

    // If no conversation exists, create one
    if (!conversation) {
      conversation = await Conversation.create({
        type: 'direct',
        participants: [currentUserId, targetUserId],
        createdBy: currentUserId,
        lastMessageAt: new Date(),
      });

      await conversation.populate('participants', 'name username avatar isOnline lastSeen');
    }

    res.status(200).json({
      success: true,
      conversation,
      isNew: !conversation.lastMessage, // True if no messages sent yet
    });
  } catch (error) {
    console.error('Start direct conversation error:', error);
    res.status(500).json({ error: 'Failed to start conversation' });
  }
}






import { NextApiRequest, NextApiResponse } from 'next';
import connectDB from '../../../lib/mongodb';
import Message from '../../../models/Message';
import Conversation from '../../../models/Conversation';
import { verifyToken } from '../../../lib/auth';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    await connectDB();
    
    const { conversationId } = req.query;
    const { page = 1, limit = 50 } = req.query;
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = verifyToken(token);
    const userId = decoded.userId;

    // Verify user is participant in conversation
    const conversation = await Conversation.findById(conversationId);
    if (!conversation || !conversation.participants.includes(userId)) {
      return res.status(403).json({ error: 'Access denied' });
    }

    // Get messages with pagination
    const skip = (Number(page) - 1) * Number(limit);
    const messages = await Message.find({
      conversationId,
      isDeleted: false,
      deletedFor: { $ne: userId },
    })
      .populate('sender', 'name username avatar')
      .populate('replyTo', 'content sender')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(Number(limit))
      .lean();

    // Reverse to get chronological order
    messages.reverse();

    const total = await Message.countDocuments({
      conversationId,
      isDeleted: false,
      deletedFor: { $ne: userId },
    });

    res.status(200).json({
      messages,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        pages: Math.ceil(total / Number(limit)),
      },
    });
  } catch (error) {
    console.error('Get messages error:', error);
    res.status(500).json({ error: 'Failed to get messages' });
  }
}






